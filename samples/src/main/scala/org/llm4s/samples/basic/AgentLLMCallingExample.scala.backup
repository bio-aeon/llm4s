package org.llm4s.samples.basic

import org.llm4s.llmconnect.LLM
import org.llm4s.agent.{Agent, AgentState, AgentStatus}
import org.llm4s.toolapi.ToolRegistry
import org.llm4s.toolapi.tools.CalculatorTool
import org.llm4s.trace.{EnhancedTracing, TracingMode, TraceEvent, TracingComposer}
import org.llm4s.samples.util.{BenchmarkUtil, TracingUtil}

import org.slf4j.LoggerFactory

/**
 * Enhanced example demonstrating the difference between basic LLM calls and the Agent framework
 * 
 * This example shows:
 * 1. Basic LLM call (simple request ‚Üí response)
 * 2. Agent framework (complex reasoning ‚Üí tool usage ‚Üí enhanced response)
 * 3. Real LLM4S tracing with all modes combined (Langfuse + Console + NoOp)
 * 4. Performance metrics and comparison
 * 
 * To enable Langfuse tracing, set these environment variables:
 * - LANGFUSE_URL: Your Langfuse instance URL (default: https://cloud.langfuse.com/api/public/ingestion)
 * - LANGFUSE_PUBLIC_KEY: Your Langfuse public key
 * - LANGFUSE_SECRET_KEY: Your Langfuse secret key
 * - LANGFUSE_ENV: Environment name (default: production)
 * - LANGFUSE_RELEASE: Release version (default: 1.0.0)
 * - LANGFUSE_VERSION: API version (default: 1.0.0)
 */
object AgentLLMCallingExample {
  private val logger = LoggerFactory.getLogger(getClass)
  
  def main(args: Array[String]): Unit = {
    logger.info("üßÆ Calculator Tool Agent Demo with Tracing")
    logger.info("=" * 50)
    
    // Create tracing based on environment variable
    val tracing = createComprehensiveTracing()
    
    // Log the tracing configuration
    logger.info("üîç Tracing Configuration:")
    logger.info("   ‚Ä¢ Mode: {}", sys.env.getOrElse("TRACING_MODE", "console"))
    logger.info("   ‚Ä¢ Langfuse URL: {}", sys.env.getOrElse("LANGFUSE_URL", "default"))
    logger.info("   ‚Ä¢ Langfuse Public Key: {}", if (sys.env.contains("LANGFUSE_PUBLIC_KEY")) "SET" else "NOT SET")
    logger.info("   ‚Ä¢ Langfuse Secret Key: {}", if (sys.env.contains("LANGFUSE_SECRET_KEY")) "SET" else "NOT SET")
    
    // Test tracing with a simple event
    logger.info("üß™ Testing tracing...")
    TracingUtil.traceDemoStart(tracing, "Calculator Tool Agent")
    logger.info("üß™ Tracing initialized successfully")
    
    // Calculator Agent Demo
    demonstrateCalculatorAgent(tracing)
    
    logger.info("=" * 50)
    logger.info("‚ú® Calculator Demo Complete!")
  }
  
  /**
   * Create comprehensive tracing with all three modes combined
   */
  private def createComprehensiveTracing(): EnhancedTracing = {
    try {
      // Create individual tracers
      val langfuseTracing = EnhancedTracing.create(TracingMode.Langfuse)
      val consoleTracing = EnhancedTracing.create(TracingMode.Console)
      val noOpTracing = EnhancedTracing.create(TracingMode.NoOp)
      
      logger.info("‚úÖ All tracing modes initialized successfully")
      
      // Combine all tracers into one comprehensive tracer
      val combinedTracing = TracingComposer.combine(
        langfuseTracing,  // Primary: sends to Langfuse
        consoleTracing,   // Secondary: shows in console
        noOpTracing       // Tertiary: no-op (for performance monitoring)
      )
      
      logger.info("üîó Combined tracing modes: Langfuse + Console + NoOp")
      combinedTracing
      
    } catch {
      case e: Exception =>
        logger.warn("‚ö†Ô∏è  Some tracing modes failed: {}", e.getMessage)
        logger.info("üîÑ Falling back to console tracing only")
        EnhancedTracing.create(TracingMode.Console)
    }
  }
  
  /**
   * Simple Calculator Agent Demo
   */
  private def demonstrateCalculatorAgent(tracing: EnhancedTracing): Unit = {
    logger.info("üßÆ Calculator Agent Demo")
    logger.info("Testing calculator tool with agent framework")
    
    val benchmarkResult = BenchmarkUtil.timeWithSteps { timer =>
    
    // Create tool registry with just calculator
    val tools = Seq(CalculatorTool.tool)
    val toolRegistry = new ToolRegistry(tools)
    
    logger.info("üîß Available Tools:")
    tools.foreach { tool =>
      logger.info("‚Ä¢ {}: {}", tool.name, tool.description)
    }
    
    // Create agent with LLM client
    val llmClient = LLM.client()
    val agent = new Agent(llmClient)
    
    // Initialize agent state with tools and query
    val query = "Calculate 15 to the power of 3, and then calculate the square root of that result."
    
    val agentState = agent.initialize(
      query = query,
      tools = toolRegistry,
      systemPromptAddition = Some("You have access to a calculator tool. Use it to perform mathematical calculations. IMPORTANT: Make only ONE tool call at a time, wait for the result, then make the next tool call if needed.")
    )
    
    // Trace agent initialization
    TracingUtil.traceAgentInitialization(tracing, query, tools)
    
    logger.info("üîÑ Running calculator agent...")
    logger.info("Query: {}", query)
    
      // Execute agent with real step-by-step execution
      executeAgentWithRealTracing(agent, agentState, tracing, timer)
    }
    
    val agentResult = benchmarkResult.result
    val duration = benchmarkResult.durationMs
    
    // Trace the agent execution
    TracingUtil.traceAgentCompletion(
      tracing,
      duration,
      agentResult.steps,
      agentResult.toolsUsed,
      agentResult.finalResponse.length
    )
    
    logger.info("‚úÖ Calculator agent completed in {}ms", duration)
    
    // Display final response
    logger.info("üéØ Final Agent Response:")
    logger.info(agentResult.finalResponse)
    
    // Performance metrics
    logger.info("üìä Performance Metrics:")
    logger.info("‚Ä¢ Total Execution Time: {}ms", duration)
    logger.info("‚Ä¢ Reasoning Steps: {}", agentResult.steps.length)
    logger.info("‚Ä¢ Tools Used: {}", agentResult.toolsUsed.length)
  }
  
  /**
   * Execute agent with real LLM4S tracing and step-by-step display
   */
  private def executeAgentWithRealTracing(agent: Agent, agentState: AgentState, tracing: EnhancedTracing, timer: BenchmarkUtil.Timer): AgentExecutionResult = {
    
    case class ExecutionState(
      agentState: AgentState,
      steps: Vector[String],
      toolsUsed: Vector[String],
      processedToolMessages: Int,
      finalResponse: String
    )
    
    logger.info("üß† Agent Reasoning Process:")
    
    // Trace initial agent state
    TracingUtil.traceAgentStateUpdate(tracing, agentState)
    
    // Use functional approach with recursion instead of mutable vars
    def executeSteps(state: ExecutionState, stepCount: Int): ExecutionState = {
      if (state.agentState.status != AgentStatus.InProgress || stepCount >= 10) {
        return state
      }
      
      val stepTimer = timer.stepTimer()
      val currentStepCount = stepCount + 1
      
      logger.info("{}. Running agent step...", currentStepCount)
      
      // Run the actual agent step
      agent.runStep(state.agentState) match {
        case Right(newAgentState) =>
          val updatedState = processAgentStep(state.copy(agentState = newAgentState), tracing, stepTimer, currentStepCount)
          executeSteps(updatedState, currentStepCount)
        case Left(error) =>
          handleAgentError(state, error, tracing, currentStepCount, stepTimer)
      }
    }
    
    val initialState = ExecutionState(
      agentState = agentState,
      steps = Vector.empty[String],
      toolsUsed = Vector.empty[String],
      processedToolMessages = 0,
      finalResponse = ""
    )
    
    val finalState = executeSteps(initialState, 0)
    
    // Generate final response
    val finalResponse = if (finalState.agentState.status == AgentStatus.Complete) {
      finalState.agentState.conversation.messages.lastOption.map(_.content).getOrElse("No final response generated")
    } else {
      s"Agent execution stopped with status: ${finalState.agentState.status}"
    }
    
    logger.info("üéØ Final Response Generated Successfully!")
    
    AgentExecutionResult(finalState.steps, finalState.toolsUsed.distinct, finalResponse)
  }
  
  private def processAgentStep(state: ExecutionState, tracing: EnhancedTracing, stepTimer: BenchmarkUtil.Timer, stepCount: Int): ExecutionState = {
    val newAgentState = continueStepUntilComplete(state.agentState)
          
          // Continue running steps until the agent completes or fails
          while (currentState.status == AgentStatus.WaitingForTools || currentState.status == AgentStatus.InProgress) {
            agent.runStep(currentState) match {
              case Right(nextState) =>
                currentState = nextState
                logger.info("   ‚Ü≥ Continued to: {}", currentState.status)
                
                // Check for new tool executions and trace them
                val allToolMessages = nextState.conversation.messages.collect { 
                  case toolMsg: org.llm4s.llmconnect.model.ToolMessage => toolMsg 
                }
                val newToolMessages = allToolMessages.drop(processedToolMessages)
                
                newToolMessages.foreach { toolMsg =>
                  // Parse the tool result to extract useful information
                  TracingUtil.parseToolResult(toolMsg.content) match {
                    case Some(toolResult) =>
                      logger.info("   üìä Tool result captured: {} = {}", toolResult.expression, toolResult.result)
                      toolsUsed = toolsUsed :+ toolResult.operation
                      
                      // Trace the tool execution with real results
                      TracingUtil.traceToolExecution(
                        tracing,
                        toolResult.operation,
                        toolResult.operation,
                        toolResult.parameters,
                        toolResult.result,
                        toolResult.expression
                      )
                    case None =>
                      // If parsing fails, just log the raw content
                      logger.info("   üìä Tool result: {}", toolMsg.content)
                  }
                  processedToolMessages += 1
                }
                
              case Left(error) =>
                logger.error("   ‚ùå Continuation failed: {}", error.message)
                currentState = currentState.withStatus(AgentStatus.Failed(error.message))
            }
          }
          
          // Trace the step completion
          TracingUtil.traceAgentStateUpdate(tracing, currentState)
          
                     // Check if tools were used - only AssistantMessage has toolCalls
           val lastMessage = currentState.conversation.messages.lastOption
           lastMessage.foreach { msg =>
             msg match {
               case assistantMsg: org.llm4s.llmconnect.model.AssistantMessage if assistantMsg.toolCalls.nonEmpty =>
                 logger.info("   üîß Tool calls detected: {}", assistantMsg.toolCalls.map(_.name).mkString(", "))
                 toolsUsed = toolsUsed ++ assistantMsg.toolCalls.map(_.name)
                 
                 // Tool execution will be traced by the agent itself with real results
               case _ => // Not an assistant message or no tool calls
             }
           }
          
          steps = steps :+ s"Step ${stepCount}: ${currentState.status}"
          
         case Left(error) =>
           logger.error("   ‚ùå Step failed: {}", error.message)
           
           // Trace the error
           TracingUtil.traceAgentStepError(tracing, stepCount, error.message)
           
           currentState = currentState.withStatus(AgentStatus.Failed(error.message))
           steps = steps :+ s"Step ${stepCount}: Failed - ${error.message}"
      }
      
      val stepDuration = stepTimer.elapsedMs
      logger.info("   ‚è±Ô∏è  Step completed in {}ms", stepDuration)
      
             // If agent is complete, break out of the loop
       if (currentState.status == AgentStatus.Complete) {
         logger.info("   üéØ Agent completed successfully!")
         stepCount = maxSteps // Force loop to end
       }
    }
    
    // Generate final response based on actual agent state
    if (currentState.status == AgentStatus.Complete) {
      finalResponse = currentState.conversation.messages.lastOption.map(_.content).getOrElse("No final response generated")
    } else {
      finalResponse = s"Agent execution stopped with status: ${currentState.status}"
    }
    
    logger.info("üéØ Final Response Generated Successfully!")
    
    AgentExecutionResult(steps, toolsUsed.distinct, finalResponse)
  }
  

  
  /**
   * Case class to hold agent execution results
   */
  case class AgentExecutionResult(
    steps: Vector[String],
    toolsUsed: Vector[String],
    finalResponse: String
  )
}
